= Procesamento Digital de Imagens =
== Introdução ==
Processamento digital de imagens é toda manipulação pelo computador, sistema, que tem como entrada e saída uma imagem. O processamento de imagens vem crescendo muito, sendo importante em diversas áreas. Na área médica, por exemplo, um padrão de armazenamento e transferência de imagens, DICOM (Digital Imaging and Communications in Medicine), se tornou imprenscindível, facilitando o dia a dia dos médicos. 

Sabido da importância, tarefas da disciplina de Processamento Digital de Imagens, com o intuito de fortalecer os conceitos teóricos apresentados em sala de aula, foram feitas e serão apresentadas posteriormente. É importante dizer que a ferramenta utilizada para o desenvolvimento dos exercícios, foi o OpenCV. O OpenCV é uma biblioteca multiplataforma, com suporte para Python, C++, C e outras linguagens de programação, para o desenvolvimento de aplicações na área de visão computacional.
== Desenvolvimento ==
Os exercícios foram resolvidos utilizando o OpenCV, ferramenta utilizada em processamento digital de imagens, como dito anteriormente, e a linguagem de programação, c++. Essa linguagem  foi escolhida por causa dos exemplos tomados como referência estarem em c++ e a uma vasta documentação encontrada facilmente na internet. Logo a seguir a descrição do problema, comentários a respeito do programa e os códigos de cada tarefa resolvida serão apresentados.  

=== Tarefa 1 ===
Tem como objetivo aprender a manipular pixels de uma imagem. Segue abaixo a descrição da tarefa

[[  , ]]
#include <iostream>
#include <opencv2/opencv.hpp>

using namespace cv;
using namespace std;

void printmask(Mat &m){
  for(int i=0; i<m.size().height; i++){
    for(int j=0; j<m.size().width; j++){
      cout << m.at<float>(i,j) << ",";
    }
    cout << endl;
  }
}

void menu(){
  cout << "\npressione a tecla para ativar o filtro: \n"
	"a - calcular modulo\n"
    "m - media\n"
    "g - gauss\n"
    "v - vertical\n"
	"h - horizontal\n"
    "l - laplaciano\n"
      "t - laplaciano-gaussiano\n"
	"esc - sair\n";
}

int main(int argvc, char** argv){
  VideoCapture video;
  //Maskaras
  float media[] = {1,1,1,
				   1,1,1,
				   1,1,1};
  float gauss[] = {1,2,1,
				   2,4,2,
				   1,2,1};
  float horizontal[]={-1,0,1,
					  -2,0,2,
					  -1,0,1};
  float vertical[]={-1,-2,-1,
					0,0,0,
					1,2,1};
  float laplacian[]={0,-1,0,
					 -1,4,-1,
					 0,-1,0};
  //Declaração das variáveis do tipo Mat
  Mat cap, frame, frame32f, frameFiltered;
  Mat mask(3,3,CV_32F), mask1;
  Mat result, result1;
  // double width, height, min, max;
  int absolut;
  char key;

  video.open(0);
  if(!video.isOpened())
    return -1;
  // width=video.get(CV_CAP_PROP_FRAME_WIDTH);
  // height=video.get(CV_CAP_PROP_FRAME_HEIGHT);
  // std::cout << "largura=" << width << "\n";;
  // std::cout << "altura =" << height<< "\n";;

  namedWindow("filtroespacial",1);

  mask = Mat(3, 3, CV_32F, media);
  scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
  swap(mask, mask1);
  absolut=1; // calcs abs of the image

  menu();
  for(;;){
    video >> cap;
    //Converte cap em cinza e manda pra frame
    cvtColor(cap, frame, COLOR_BGR2GRAY);
    flip(frame, frame, 1);
    //Mostra imagens originais
    imshow("original", frame);
    //Frame é convertido pra ponto flutuante e jogado em frame32f
    //Filtra e joga em frameFiltered. Usa mask como maskara
    frame.convertTo(frame32f, CV_32F);
    filter2D(frame32f, frameFiltered, frame32f.depth(), mask, Point(1,1), 0);

    if(absolut){
      frameFiltered=abs(frameFiltered);
    }
    //Converte frameFiltered pra poder exibir
    frameFiltered.convertTo(result, CV_8U);
    imshow("filtroespacial", result);

    key = (char) waitKey(10);
    if( key == 27 ) break; // esc pressed!
    switch(key){
    case 'a':
	  menu();
      absolut=!absolut;
      break;
    case 'm':
	  menu();
      mask = Mat(3, 3, CV_32F, media);
      scaleAdd(mask, 1/9.0, Mat::zeros(3,3,CV_32F), mask1);
      mask = mask1;
      printmask(mask);
      break;
    case 'g':
	  menu();
      mask = Mat(3, 3, CV_32F, gauss);
      scaleAdd(mask, 1/16.0, Mat::zeros(3,3,CV_32F), mask1);
      mask = mask1;
      printmask(mask);
      break;
    case 'h':
	  menu();
      mask = Mat(3, 3, CV_32F, horizontal);
      printmask(mask);
      break;
    case 'v':
	  menu();
      mask = Mat(3, 3, CV_32F, vertical);
      printmask(mask);
      break;
    case 'l':
	  menu();
      mask = Mat(3, 3, CV_32F, laplacian);
      printmask(mask);
      break;
    case 't':
      menu();
        mask = Mat(3, 3, CV_32F, gauss);
        scaleAdd(mask, 1/16.0, Mat::zeros(3,3,CV_32F), mask1);
        mask = mask1;
        mask = Mat(3,3, CV_32F, laplacian);
        std::cout << "Laplaciano-gaussiano" << std::endl;
        break;

    default:
      break;
    }
  }
  return 0;
}

[source,cpp]

=== Tarefa 2 ===
Seguindo a mesma linha da questão anterior, manipulação de pixels. 
=== Tarefa 3 ===
=== Tarefa 4 ===
== Conclusão ==
== Bibliografia ==
